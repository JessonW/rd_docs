<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">

	<title>客户端-安卓 - AbleCloud 开发文档</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation" style="background:#00b5f1;border:0px solid transparent;height:50px;">
    <div class="container container-ac">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="../../introduction/"><img src="../../img/logo.png" /><span style="margin-left:20px; margin-right:20px;">|</span>开发文档</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse" style="margin-left:293px;">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav nav-ac">
                
                
                    <li >
                        <a href="../../introduction/" >基本介绍</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">功能说明 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../features/concepts/">基本概念</a>
</li>

                        
                            
<li >
    <a href="../../features/functions/">功能介绍</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">开发指导 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="./">客户端-安卓</a>
</li>

                        
                            
<li >
    <a href="../iOS/">客户端-iOS</a>
</li>

                        
                            
<li >
    <a href="../wechat/">客户端-微信</a>
</li>

                        
                            
<li >
    <a href="../device/">设备-嵌入式系统</a>
</li>

                        
                            
<li >
    <a href="../device_android/">设备-安卓系统</a>
</li>

                        
                            
<li >
    <a href="../device_linux/">设备-linux系统</a>
</li>

                        
                            
<li >
    <a href="../cloud/">云端服务</a>
</li>

                        
                            
<li >
    <a href="../third_proxy/">第三方云对接</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Reference <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../reference/android/">客户端-安卓</a>
</li>

                        
                            
<li >
    <a href="../../reference/iOS/">客户端-iOS</a>
</li>

                        
                            
<li >
    <a href="../../reference/wechat/">客户端-微信</a>
</li>

                        
                            
<li >
    <a href="../../reference/device/">设备-嵌入式系统</a>
</li>

                        
                            
<li >
    <a href="../../reference/device_android/">设备-安卓系统</a>
</li>

                        
                            
<li >
    <a href="../../reference/device_linux/">设备-linux系统</a>
</li>

                        
                            
<li >
    <a href="../../reference/cloud/">云端服务</a>
</li>

                        
                            
<li >
    <a href="../../reference/error_code/">Error Code</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../../QandA/" >Q&A</a>
                    </li>
                
                
                </ul>
            
        </div>
    </div>
</div>

        <div class="container container-ac">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        
        
        
        <li class="main active">
            <a href="#_1">安卓客户端开发指导</a>
        </li>
        
    
        
        
            
                
            
        
            
                
            
        
            
                
            
        
        
        <li class="main">
            <a href="#_2">开发环境配置<span class="main-set parent__2">+</span></a>
        </li>
        
            
            <li class="sub parent__2" style="display: none;"><a href="#sdk">SDK发布库</a></li>
            
        
            
            <li class="sub parent__2" style="display: none;"><a href="#_3">开发环境设置</a></li>
            
        
            
            <li class="sub parent__2" style="display: none;"><a href="#_4">应用程序初始化</a></li>
            
        
    
        
        
            
                
            
        
            
                
            
        
            
                
            
        
        
        <li class="main">
            <a href="#_5">帐号管理<span class="main-set parent__5">+</span></a>
        </li>
        
            
            <li class="sub parent__5" style="display: none;"><a href="#_6">一、普通帐号注册</a></li>
            
        
            
            <li class="sub parent__5" style="display: none;"><a href="#_9">二、第三方登录</a></li>
            
        
            
            <li class="sub parent__5" style="display: none;"><a href="#_10">三、添加帐号扩展属性</a></li>
            
        
    
        
        
            
                
            
        
            
                
            
        
            
                
            
        
            
                
            
        
        
        <li class="main">
            <a href="#_11">设备管理<span class="main-set parent__11">+</span></a>
        </li>
        
            
            <li class="sub parent__11" style="display: none;"><a href="#_12">独立设备</a></li>
            
        
            
            <li class="sub parent__11" style="display: none;"><a href="#_16">网关型设备</a></li>
            
        
            
            <li class="sub parent__11" style="display: none;"><a href="#home">Home模型</a></li>
            
        
            
            <li class="sub parent__11" style="display: none;"><a href="#_21">设备附加属性</a></li>
            
        
    
        
        
            
                
            
        
            
                
            
        
            
                
            
        
        
        <li class="main">
            <a href="#_24">和云端通信<span class="main-set parent__24">+</span></a>
        </li>
        
            
            <li class="sub parent__24" style="display: none;"><a href="#_25">一、发送消息到设备</a></li>
            
        
            
            <li class="sub parent__24" style="display: none;"><a href="#_27">二、发送消息到服务</a></li>
            
        
            
            <li class="sub parent__24" style="display: none;"><a href="#_28">三、实时消息</a></li>
            
        
    
        
        
        
        <li class="main">
            <a href="#_29">局域网通信</a>
        </li>
        
    
        
        
            
        
        
        <li class="main">
            <a href="#_30">定时任务</a>
        </li>
        
            
        
    
        
        
            
        
        
        <li class="main">
            <a href="#ota">OTA</a>
        </li>
        
            
        
    
        
        
            
                
            
        
            
                
            
        
            
                
            
        
        
        <li class="main">
            <a href="#_40">推送<span class="main-set parent__40">+</span></a>
        </li>
        
            
            <li class="sub parent__40" style="display: none;"><a href="#_41">推送开发准备</a></li>
            
        
            
            <li class="sub parent__40" style="display: none;"><a href="#_42">一、推送开发环境配置</a></li>
            
        
            
            <li class="sub parent__40" style="display: none;"><a href="#_43">二、开启推送服务</a></li>
            
        
    
        
        
            
                
            
        
            
                
            
        
            
                
            
        
        
        <li class="main">
            <a href="#_44">文件存储<span class="main-set parent__44">+</span></a>
        </li>
        
            
            <li class="sub parent__44" style="display: none;"><a href="#_45">一、获取文件管理器</a></li>
            
        
            
            <li class="sub parent__44" style="display: none;"><a href="#_46">二、下载文件</a></li>
            
        
            
            <li class="sub parent__44" style="display: none;"><a href="#_47">三、上传文件</a></li>
            
        
    
        
        
        
        <li class="main">
            <a href="#error-code">Error Code</a>
        </li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="_1">安卓客户端开发指导</h1>
<h1 id="_2">开发环境配置</h1>
<h2 id="sdk">SDK发布库</h2>
<p>ablcloud发布的android端SDK为<a href="https://www.ablecloud.cn/download/SDK&amp;Demo/ac-service-android-SDK-1.0.1.zip"><code>ac-service-android.jar</code></a></p>
<blockquote>
<p><font color="red">注意:</font></p>
<p>1、若您设备的wifi模块为MTK，则需要添加MTK文件夹下的文件到libs目录下</p>
<p>2、若需要使用友盟的推送服务，则需要添加Umeng文件夹下的文件到libs目录下</p>
</blockquote>
<h2 id="_3">开发环境设置</h2>
<p>以下为 AbleCloud Android SDK 需要的所有的权限，请在你的AndroidManifest.xml文件里的<code>&lt;manifest&gt;</code>标签里添加</p>
<pre><code class="java">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot;/&gt;
</code></pre>

<h2 id="_4">应用程序初始化</h2>
<p>在你的应用使用AbleCloud服务之前，你需要在代码中对AbleCloud SDK进行初始化。
继承<code>Application</code>类，并且在<code>onCreate()</code>方法中调用此方法来进行初始化</p>
<p>开发阶段，请初始化<strong>测试环境</strong></p>
<pre><code class="java">AC.init(this, MajorDomain, MajorDomainId, AC.TEST_MODE);
</code></pre>

<p>在完成测试阶段之后，需要迁移到<strong>正式环境</strong>下</p>
<pre><code class="java">AC.init(this, MajorDomain, MajorDomainId);
</code></pre>

<h1 id="_5">帐号管理</h1>
<h2 id="_6">一、普通帐号注册</h2>
<p>功能介绍参考： <a href="../../features/functions/#_1">功能说明-功能介绍-帐号管理</a></p>
<p><img alt="account_register" src="../../pic/develop_guide/account_register.png" /></p>
<h3 id="_7">获取账号管理对象</h3>
<pre><code class="java">    ACAccountMgr accountMgr=AC.accountMgr();
</code></pre>

<h3 id="_8">普通帐号注册流程</h3>
<h4 id="1">1、检查手机号是否已注册</h4>
<pre><code class="java">    AC.accountMgr().checkExist(phone, new PayloadCallback&lt;Boolean&gt;() {
        @Override
        public void success(Boolean isExist) {
            if (!isExist) {
                //发送验证码
            } else {
                //提示手机号已被注册 
            }
        }
        @Override
        public void error(ACException e) {
            //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
        }
    });
</code></pre>

<h4 id="2">2、发送验证码</h4>
<pre><code class="java">    AC.accountMgr().sendVerifyCode(phone, 1, new VoidCallback() {
        @Override
        public void success() {
            //检测验证码
        }
        @Override
        public void error(ACException e) {
            //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
        }
    });
</code></pre>

<h4 id="3">3、检测验证码正确性</h4>
<pre><code class="java">    AC.accountMgr().checkVerifyCode(phone，code, new PayloadCallback&lt;Boolean&gt;() {
        @Override
        public void success(Boolean result) {
            if (result) {
                //注册
            } else {
                //提示验证码错误 
            }
        }
        @Override
        public void error(ACException e) {
            //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
        }
    });
</code></pre>

<h4 id="4">4、注册</h4>
<pre><code class="java">    AC.accountMgr().register(&quot;&quot;, phone, password, name, verifyCode, new PayloadCallback&lt;ACUserInfo&gt;() {
        @Override
        public void success(ACUserInfo userInfo) {
            //获得用户userId和nickName，进入主页或设备管理
        }   
        @Override
        public void error(ACException e) {
            //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
        }
    });
</code></pre>

<h2 id="_9">二、第三方登录</h2>
<p><img alt="account_Oauth" src="../../pic/develop_guide/account_Oauth.png" /></p>
<h4 id="1_1">1、直接使用第三方登录</h4>
<pre><code class="java">    //APP端在完成OAuth认证登陆之后获取openId和accessToken
    AC.accountMgr().loginWithOpenId(ACThirdPlatform.QQ, openId, accessToken, new PayloadCallback&lt;ACUserInfo&gt;() {
        @Override
        public void success(ACUserInfo userInfo) {
            //获得用户userId和nickName，进入主页或设备管理
        }   
        @Override
        public void error(ACException e) {
            //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
        }
    });
    //绑定一个未被注册的普通帐号
    AC.accountMgr().bindWithAccount( email, phone, password, nickName, verifyCode, new VoidCallback() {
        @Override
        public void success() {
            //绑定账号成功
        }
        @Override
        public void error(ACException e) {
            //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
        }
    });
</code></pre>

<h4 id="2_1">2、在已有普通账号登录时绑定第三方账号</h4>
<pre><code class="java">    AC.accountMgr().bindWithAccount( email, phone, password, nickName, verifyCode, new VoidCallback() {
        @Override
        public void success() {
            //绑定第三方账号成功
        }
        @Override
        public void error(ACException e) {
            //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
        }
    });
</code></pre>

<h2 id="_10">三、添加帐号扩展属性</h2>
<p>使用账号扩展属性需要先到AbleCloud官网平台上的用户管理添加附加属性</p>
<h4 id="1_2">1、获取账号管理器</h4>
<pre><code class="java">accountMgr=AC.accountMgr();
</code></pre>

<h4 id="2_2">2、设置用户自定义扩展属性</h4>
<pre><code class="java">ACObject userProfile = new ACObject();
//注意此处put进去的key与value类型需要跟平台添加的附加属性一致
userProfile.put(&quot;c1&quot;, &quot;北京&quot;);
userProfile.put(&quot;c2&quot;, &quot;生日&quot;);
accountMgr.setUserProfile(userProfile, new VoidCallback() {
    @Override
    public void success() {
         //附加属性设置成功
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h4 id="3_1">3、获取用户自定义扩展属性</h4>
<pre><code class="java">accountMgr.getUserProfile(new PayloadCallback&lt;ACObject&gt;() {
     @Override
     public void success(ACObject object) {
         //可通过object.toString()查看扩展属性信息
     }

     @Override
     public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
     }
});
</code></pre>

<h1 id="_11">设备管理</h1>
<h2 id="_12">独立设备</h2>
<p>功能介绍参见 <a href="../../features/functions/#_3">功能说明-功能介绍-独立设备管理</a></p>
<p><strong>用户登录/注册后，需要绑定设备才能够使用。对于wifi设备，绑定设备时，首先需在APP上给出配置设备进入Smartconfig状态的提示；然后填写当前手机连接的WiFi的密码，调用startAbleLink将WiFi密码广播给设备，设备拿到WiFi密码后连接到云端然后开始局域网广播自己的物理Id和subdomainID，APP拿到这些信息后调用bindDevice接口绑定设备。对于GPRS设备，则无需以上设备激活的流程，通过扫码或其他方式获取物理Id后调用bindDevice进行绑定。</strong></p>
<p><img alt="DM_wifi" src="../../pic/develop_guide/DM_WiFi.png" /></p>
<h3 id="_13">一．绑定设备</h3>
<h3 id="wifi">WiFi设备</h3>
<h4 id="1acdeviceactivator">1.获取ACDeviceActivator激活器</h4>
<p>Ablecloud提供了ACDeviceActivator激活器供你使用，具体使用步骤如下：</p>
<pre><code class="java">ACDeviceActivator deviceActivator=AC.deviceActivator(AC.DEVICE_HF);
</code></pre>

<blockquote>
<p><font color="red">注</font>：<code>AC.DEVICE_HF</code>表示汉枫的开发板，如果用的是其它的开发板，则需要改成相对应的值。
目前支持的开发板有<code>AC.DEVICE_MTK</code>、<code>AC.DEVICE_MX</code>、<code>AC.DEVICE_MARVELL</code>、<code>AC.DEVICE_MURATA</code>、<code>AC.DEVICE_WM</code>、<code>AC.DEVICE_RAK</code>。</p>
</blockquote>
<h4 id="2wifi-ssid">2.获取WiFi SSID</h4>
<pre><code class="java">deviceActivator. getSSID()
</code></pre>

<h4 id="3_2">3.激活设备</h4>
<p>APP通过startAbleLink广播自己的WiFi密码，设备成功连上云之后通过广播通知APP同时获取设备物理Id和subDomainId（用来区分设备类型）。当前只支持配置手机当前连接的WiFi。</p>
<pre><code class="java">deviceActivator.startAbleLink(ssid, password,  AC.DEVICE_ACTIVATOR_DEFAULT_TIMEOUT, new PayloadCallback&lt;List&lt;ACDeviceBind&gt;&gt;() {
    @Override
    public void success(List&lt;ACDeviceBind&gt; deviceBinds) {
        //成功后得到已激活设备的列表，从列表中得到物理id后进行绑定
    }

    @Override
    public void error(ACException e) {
        //根据e.getErrorCode()做不同的提示或处理，此处一般为1993配置超时错误
    }
});
</code></pre>

<h4 id="4_1">4.绑定设备</h4>
<p>在成功激活设备后的回调方法中，通过物理Id绑定设备。</p>
<pre><code class="java">AC.bindMgr().bindDevice(subDomain, physicalDeviceId, deviceName, new PayloadCallback&lt;ACUserDevice&gt;() {
    @Override
    public void success(ACUserDevice userDevice) {
        //绑定成功后返回设备信息
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h3 id="gprs">GPRS设备</h3>
<p><strong><font color="red">注</font>：GPRS设备无需激活流程，在设备连上云端之后即可以直接进入绑定设备的流程。</strong>建议通过扫二维码的形式获取物理Id进行绑定。</p>
<pre><code class="java">AC.bindMgr().bindDevice(subDomain, physicalDeviceId, deviceName, new PayloadCallback&lt;ACUserDevice&gt;() {
    @Override
    public void success(ACUserDevice userDevice) {
        //绑定成功后返回设备信息
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<blockquote>
<p><font color="red">建议流程</font>：若设备上有是否连接上AbleCloud云端的指示灯，则可以提示用户在指示灯亮起的时候绑定设备。若无指示灯，则可在用户点击开始绑定之后，建议通过CountDownTimer每隔2s钟绑定一次设备，在连续绑定几次之后再提示用户失败或成功。</p>
</blockquote>
<h3 id="_14">二．分享设备</h3>
<ul>
<li><strong>第一种分享方式不需要用户做任何操作，管理员把设备分享给用户后即直接拥有控制权；</strong></li>
<li><strong>第二种方式为管理员分享二维码后，用户再通过扫码的形式绑定设备才拥有控制权。推荐使用第二种分享机制。</strong></li>
</ul>
<h4 id="1_3">1、管理员直接分享设备给普通用户</h4>
<pre><code class="java">bindMgr.bindDeviceWithUser(subDomain, deviceId, account, new VoidCallback() {
    @Override
    public void success() {
         //成功分享设备给account用户
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h4 id="2_3">2、管理员通过分享设备二维码的形式分享设备</h4>
<pre><code class="java">//管理员获取分享码
bindMgr.getShareCode(subDomain, deviceId, new PayloadCallback&lt;String&gt;() {
    @Override
    public void success(String shareCode) {
         //成功获取分享码
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
//普通用户通过分享码绑定设备
bindMgr.bindDeviceWithShareCode(shareCode, new PayloadCallback&lt;ACUserDevice&gt;() {
    @Override
    public void success(ACUserDevice userDevice) {
         //成功绑定管理员分享的设备
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h3 id="_15">三．设备解绑</h3>
<h4 id="1_4">1、管理员或普通用户解绑设备</h4>
<p><font color=red>注意：</font>如果是管理员解绑设备，那么其他绑定该设备的普通成员也会失去该设备的绑定权。</p>
<pre><code class="java">bindMgr.unbindDevice(subDomain, deviceId, new VoidCallback() {
    @Override
    public void success() {
        //解绑成功
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h4 id="2_4">2、管理员取消其他普通成员对该设备的控制权</h4>
<pre><code class="java">bindMgr.unbindDeviceWithUser(subDomain, userId, deviceId, new VoidCallback() {
    @Override
    public void success() {
        //解绑成功
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h2 id="_16">网关型设备</h2>
<p>功能介绍参见 <a href="../../features/functions/#_6">功能说明-功能介绍-网关型设备管理</a></p>
<p>网关的绑定流程和WiFi设备是一样的。网关绑定以后绑定子设备的建议流程如下：</p>
<p><img alt="DM_gateway" src="../../pic/develop_guide/DM_gateway.png" /></p>
<p>该流程只是建议流程的一种。其中openGatewayMatch和closeGatewayMatch接口都是为了方便软件开启配对而开发的接口。如果使用硬件上的操作（如网关上有按钮等）完成网关和子设备的配对，则不需要用到这两个接口。</p>
<h3 id="_17">一．绑定网关</h3>
<h3 id="wifi_1">WiFi网关</h3>
<h4 id="1acdeviceactivitor">1.获取ACDeviceActivitor激活器</h4>
<p>AbleCloud提供了ACDeviceActivitor激活器供你使用。</p>
<pre><code class="java">ACDeviceActivator deviceActivator=AC.deviceActivator(AC.DEVICE_HF);
</code></pre>

<p><font color="red">注</font>：AC.DEVICE_HF表示汉枫的开发板，如果用的是其它的开发板，则需要修改。
目前支持的开发板有AC.Device_MTK、AC.Device_MX、AC.Device_MARVELL、AC.Device_MURATA、AC.Device_WM、AC.Device_RAK。</p>
<h4 id="2wifi-ssid_1">2.得到WiFi SSID</h4>
<pre><code class="java">deviceActivator. getSSID()
</code></pre>

<h4 id="3_3">3.激活网关</h4>
<p>APP通过startAbleLink广播自己的WiFi密码，设备成功连上云之后通过广播通知APP同时获取设备物理Id和subDomainId（用来区分设备类型）。当前只支持配置手机当前连接的WiFi。</p>
<pre><code class="java">deviceActivator.startAbleLink(ssid, password,  AC.DEVICE_ACTIVATOR_DEFAULT_TIMEOUT, new PayloadCallback&lt;List&lt;ACDeviceBind&gt;&gt;() {
    @Override
    public void success(List&lt;ACDeviceBind&gt; deviceBinds) {
        //成功后得到已激活设备的列表，从列表中得到物理id后进行绑定
    }

    @Override
    public void error(ACException e) {
        //根据e.getErrorCode()做不同的提示或处理，此处一般为1993配置超时错误
    }
});
</code></pre>

<h4 id="4_2">4.绑定网关</h4>
<p>在成功激活设备后的回调方法中，通过物理Id绑定网关。</p>
<pre><code class="java">AC.bindMgr().bindGateway(subDomain, physicalDeviceId, deviceName, new PayloadCallback&lt;ACUserDevice&gt;() {
    @Override
    public void success(ACUserDevice userDevice) {
        //绑定成功后返回设备信息
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h3 id="_18">以太网网关</h3>
<p><strong><font color="red">注</font>：以太网网关无需激活流程，在网关插上网线连上云端之后即可以直接进入绑定设备的流程。</strong>建议通过扫码的形式获取网关物理Id进行绑定。</p>
<pre><code class="java">AC.bindMgr().bindGateway(subDomain, physicalDeviceId, deviceName, new PayloadCallback&lt;ACUserDevice&gt;() {
    @Override
    public void success(ACUserDevice userDevice) {
        //绑定成功后返回设备信息
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h3 id="_19">二．绑定子设备</h3>
<h4 id="1_5">1．开启网关接入配对</h4>
<pre><code class="java">AC.bindMgr().openGatewayMatch(subDomain, gatewayDeviceId, AC.DEVICE_ACTIVATOR_DEFAULT_TIMEOUT, new VoidCallback(){
    @Override
    public void success() {
        //由于子设备接入网关是一个异步的过程，所以建议在这里new一个timer去定时获取新加入的子设备列表
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                //列举所有新加入的子设备列表     
            }
        }, 0, 10000);
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为设备问题
    }
});
</code></pre>

<h4 id="2_5">2．列举所有新加入的子设备列表</h4>
<pre><code class="java">AC.bindMgr().listNewDevices(subDomain, gatewayDeviceId, new PayloadCallback&lt;List&lt;ACDeviceBind&gt;&gt;() {
    @Override
    public void success(List&lt;ACDeviceBind&gt; deviceBinds) {
        //建议此处更新新加入子设备列表的界面
    }
    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为设备问题
    }
});
</code></pre>

<h4 id="3_4">3．绑定子设备</h4>
<p>通过上一步获取的子设备列表获取physicalDeviceId进行绑定。
如有用户确认过程的话，则在用户点击确认之后循环调用此接口绑定用户选择的子设备。</p>
<pre><code class="java">AC.bindMgr().addSubDevice(subDomain, gatewayDeviceId, physicalDeviceId, devcieName, new PayloadCallback&lt;ACUserDevice&gt;() {
    @Override
    public void success(ACUserDevice acUserDevice) {
        //成功绑定该子设备
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<p><font color="red">注</font>：在绑定子设备addSubDevice的success回调里只是成功绑定该physicalDeviceId的单个设备，建议在成功绑定所有子设备之后再提示绑定成功。</p>
<h2 id="home">Home模型</h2>
<p>功能介绍参见 <a href="../../features/functions/#home">功能说明-功能介绍-Home模型</a></p>
<p>创建家庭绑定WiFi设备的建议流程如下图：</p>
<p><img alt="DM_home_wifi" src="../../pic/develop_guide/DM_home_wifi.png" /></p>
<p>创建家庭然后绑定以太网或者GPRS设备的建议流程如下图：</p>
<p><img alt="DM_home_gprs" src="../../pic/develop_guide/DM_home_gprs.png" /></p>
<p>创建家庭然后绑定WiFi网关和Zigbee子设备的建议流程如下图：</p>
<p><img alt="DM_home_gateway_wifi" src="../../pic/develop_guide/DM_home_gateway_wifi.png" /></p>
<p>创建家庭，然后绑定以太网网关和Zigbee子设备的建议流程如下图：</p>
<p><img alt="DM_home_gateway_wired" src="../../pic/develop_guide/DM_home_gateway_wired.png" /></p>
<h3 id="home_1">一、创建Home</h3>
<h4 id="1home">1、获取home模型管理器</h4>
<pre><code class="java">ACGroupMgr groupMgr = AC.groupMgr();
</code></pre>

<h4 id="2home">2、创建Home</h4>
<pre><code class="java">groupMgr.createHome(name, new PayloadCallback&lt;ACHome&gt;() {
    @Override
    public void success(ACHome home) {
         //成功创建一个home
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为网络错误
    }
});
</code></pre>

<h4 id="3room">3、创建Room</h4>
<pre><code class="java">groupMgr.createRoom(homeId, name, new PayloadCallback&lt;ACRoom&gt;() {
    @Override
    public void success(ACRoom room) {
         //成功创建homeId下的一个room
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h3 id="_20">二、添加或移动设备到分组里</h3>
<blockquote>
<p><font color="red">特别注意</font>：</p>
<p>1、绑定设备流程与独立设备和网关型设备相同。建议独立设备在激活设备之后绑定设备把bindDevice换成addDeviceToHome；GPRS设备或以太网网关则直接调addDeviceToHome。</p>
<p>2、不能跨级移动设备。比如独立设备要移到room里，则需要先把它移动到home，再移动到room。</p>
</blockquote>
<h4 id="home_2">添加设备到Home里</h4>
<p>创建完分组之后，需要添加绑定设备，绑定流程见上篇独立设备或网关开发指导，把bindDevice改成如下接口即可。</p>
<pre><code class="java">groupMgr.addDeviceToHome(subDomain, physicalDeviceId, homeId, deviceName, new PayloadCallback&lt;ACUserDevice&gt;() {
    @Override
    public void success(ACUserDevice userDevice) {
         //成功绑定设备并添加到分组Home里
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h4 id="room">移动设备到Room里</h4>
<pre><code class="java">groupMgr.moveDeviceToRoom(deviceId, homeId, roomId, new VoidCallback() {
    @Override
    public void success() {
         //成功绑定设备并添加到分组Home里
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h2 id="_21">设备附加属性</h2>
<p>功能介绍参见 <a href="../../features/functions/#_11">功能说明-功能介绍-设备附加属性</a></p>
<p><strong><font color="red">注意</font>：设备扩展属性需要先进入到控制台产品管理--&gt;产品列表--&gt;管理--&gt;产品属性--&gt;附加属性--&gt;新建属性，建立完附加属性列表后才能使用如下接口。</strong></p>
<h4 id="_22">一、设置或者更新设备附加属性</h4>
<pre><code class="java">ACObject deviceProfile = new ACObject();
//这里的key值需要与控制台里新建列表的属性标识保持一致
deviceProfile.put(&quot;String&quot;, &quot;北京&quot;);
deviceProfile.put(&quot;Integer&quot;, 10);
deviceProfile.put(&quot;Float&quot;, 10.1f);
deviceProfile.put(&quot;Bool&quot;, true);
bindMgr.setDeviceProfile(subDomain, deviceId, deviceProfile, new VoidCallback() {
    @Override
    public void success() {
         //设置成功               
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为参数错误，请对照平台申请的key与value类型
    }
});
</code></pre>

<h4 id="_23">二、获取设备附加属性</h4>
<pre><code class="java">bindMgr.getDeviceProfile(subDomain, deviceId, new PayloadCallback&lt;ACObject&gt;() {
    @Override
    public void success(ACObject object) {
         //成功获取并查看设备扩展属性信息
         LogUtil.i(&quot;TAG&quot;,object.toString());
    }

    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h1 id="_24">和云端通信</h1>
<p>功能介绍参见 <a href="../../features/functions/#_12">功能说明-功能介绍-和云端通信</a></p>
<h2 id="_25">一、发送消息到设备</h2>
<h3 id="klv">KLV格式</h3>
<p><strong>在新建产品的时候选择klv通讯协议，并填写数据点与数据包。</strong>
KLV协议介绍请参考：<a href="../../reference/device/#klv">reference-设备-KLV协议介绍</a>。</p>
<p><strong>例如</strong>：以开关设备为例,协议如下:</p>
<pre><code>//请求数据包
{ 68 ：[
     //数据点[key：value(int8)]
     //关灯
     { 1 : 0 },
     //开灯      
     { 1 : 1 }
]}
//响应数据包  
{ 102 ：[
     //数据点[key：value(int8)]
     //失败
     { 1 : 0 },
     //成功      
     { 1 : 1 }
]}
</code></pre>

<p>截取开灯代码，如下:</p>
<pre><code class="java">ACKLVObject req = new ACKLVObject();
//只需要告诉设备指令，而不需要payload时，传null
req.put(1, 1);
//AC.LOCAL_FIRST代表优先走局域网，局域网不通的情况下再走云端
bindMgr.sendToDeviceWithOption(subDomain, deviceId, new ACKLVDeviceMsg(68, req), AC.LOCAL_FIRST, new PayloadCallback&lt;ACKLVDeviceMsg&gt;() {
    @Override
    public void success(ACKLVDeviceMsg deviceMsg) {
        ACKLVObject resp = deviceMsg.getKLVObject();
        //发送成功并接收设备的响应消息
        int value = resp.get(1);
        if(value==0){
            //开灯失败
        }else if(value==1){
            //开灯成功
        }
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为设备问题
    }
});
</code></pre>

<h3 id="_26">二进制格式</h3>
<p><strong>例如</strong>：以开关设备为例,协议如下:</p>
<pre><code>//请求数据包
{ 68 ：[
     //关灯(二进制流，由厂商自己解析)
     { 0 , 0 , 0 , 0 },
     //开灯(二进制流，由厂商自己解析)   
     { 1 , 0 , 0 , 0 }
]}
//响应数据包  
{ 102 ：[
     //失败(二进制流，由厂商自己解析)
     { 0 , 0 , 0 , 0 },
     //成功(二进制流，由厂商自己解析)        
     { 1 , 0 , 0 , 0 }
]}
</code></pre>

<p>截取开灯代码，如下:</p>
<h4 id="1_6">1、设置序列化器</h4>
<pre><code class="java">bindMgr.setDeviceMsgMarshaller(new ACDeviceMsgMarshaller() {
    @Override
    public byte[] marshal(ACDeviceMsg msg) throws Exception {
        return (byte[]) msg.getContent();
    }

    @Override
    public ACDeviceMsg unmarshal(int msgCode, byte[] payload) throws Exception {
        return new ACDeviceMsg(msgCode, payload);
    }
});
</code></pre>

<h4 id="2_6">2、发送到设备</h4>
<pre><code class="java">bindMgr.sendToDeviceWithOption(subDomain, deviceId, new ACDeviceMsg(68, new byte[]{1, 0, 0, 0}), AC.LOCAL_FIRST, new PayloadCallback&lt;ACDeviceMsg&gt;() {
    @Override
    public void success(ACDeviceMsg deviceMsg) {
        byte[] resp = (byte[]) deviceMsg.getContent();
        if(resp[0] == 1 &amp;&amp; resp[1] == 0 &amp;&amp; ...){
            //开灯成功
        } else {
            //开灯失败
        }
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为设备问题
    }
});
</code></pre>

<h3 id="3json">3、json格式</h3>
<p><strong>例如</strong>：以开关设备为例,协议如下:</p>
<pre><code>//请求数据包
{ 68 ：[
     //关灯
     {&quot;switch&quot;,&quot;close&quot;}
     //开灯
     {&quot;switch&quot;,&quot;open&quot;}
]}
//响应数据包  
{ 102 ：[
     //失败
     {&quot;result&quot;,0},
     //成功   
     {&quot;result&quot;,1}
]}
</code></pre>

<h4 id="1_7">1、设置序列化器</h4>
<pre><code class="java">bindMgr.setDeviceMsgMarshaller(new ACDeviceMsgMarshaller() {
    @Override
    public byte[] marshal(ACDeviceMsg msg) throws Exception {
        return ACObjectMarshaller.marshal((ACObject)msg.getContent());
    }

    @Override
    public ACDeviceMsg unmarshal(int msgCode, byte[] payload) throws Exception {
        ACObject resp = new ACObject();
        ACObjectMarshaller.unmarshal(resp, payload);
        return new ACDeviceMsg(msgCode, resp);
    }
});
</code></pre>

<h4 id="2_7">2、发送到设备</h4>
<pre><code class="java">ACObject req = new ACObject();
req.put(&quot;switch&quot;, &quot;open&quot;);
bindMgr.sendToDeviceWithOption(subDomain, deviceId, new ACDeviceMsg(68, req), AC.LOCAL_FIRST, new PayloadCallback&lt;ACDeviceMsg&gt;() {
    @Override
    public void success(ACDeviceMsg deviceMsg) {
        ACObject resp = (ACObject) deviceMsg.getContent();
        long result = resp.get(&quot;result&quot;);
        if (result == 1) {
            //开灯成功
        } else {
            //开灯失败
        }
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为设备问题
    }
});
</code></pre>

<h2 id="_27">二、发送消息到服务</h2>
<p><font color="red">注意</font>：serviceName对应服务管理里UDS服务里的<strong>服务名称</strong>，务必保持一致。进入版本管理之后，查看已上线版本。serviceVersion为<strong>主版本号</strong>，比如1-0-0，则version为1。</p>
<pre><code class="java">ACMsg req = new ACMsg();
req.setName(&quot;queryData&quot;);
req.put(&quot;deviceId&quot;, deviceId);
req.put(&quot;startTime&quot;, 0);
req.put(&quot;endTime&quot;, System.currentTimeMillis());
AC.sendToService(subDomain, serviceName, serviceVersion, req, new PayloadCallback&lt;ACMsg&gt;() {
    @Override
    public void success(ACMsg resp) {
        //发送成功并接收服务的响应消息
    }

    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为UDS云端问题，可到AbleCloud平台查看log日志
    }
});
</code></pre>

<h2 id="_28">三、实时消息</h2>
<p>实时消息第一版的设计与store数据集直接相关，当数据表格的存储有发生变化时，如创建、更新、添加、删除操作时才会下发数据到APP。</p>
<p><img alt="cloud_syn" src="../../pic/develop_guide/cloud_syn.png" /></p>
<h4 id="1_8">1、获取实时消息管理器</h4>
<pre><code class="java">pushMgr = AC.pushMgr();
</code></pre>

<h4 id="2_8">2、创建与服务器的连接</h4>
<pre><code class="java">pushMgr.connect(new VoidCallback() {
    @Override
    public void success() {
        //连接成功，可以开始订阅数据
    }
    @Override
    public void error(ACException e) {
        //网络错误，连接失败
    }
});
</code></pre>

<h4 id="3_5">3、订阅实时数据</h4>
<pre><code class="java">//实例化ACPushTable对象
ACPushTable table = new ACPushTable();
//设置订阅的表名
table.setClassName(&quot;test_class&quot;);
//设置订阅的columns行
table.setColumes(new String[]{&quot;status&quot;, &quot;pm25&quot;});
//设置监听主键，此处对应添加数据集时的监控主键
ACObject primaryKey = new ACObject();
primaryKey.put(&quot;deviceId&quot;, &quot;10000&quot;);
table.setPrimaryKey(primaryKey);
//设置监听类型，如以下为只要发生创建、删除、替换、更新数据集的时候即会推送数据
table.setOpType(ACPushTable.OPTYPE_CREATE | ACPushTable.OPTYPE_DELETE | ACPushTable.OPTYPE_REPLACE | ACPushTable.OPTYPE_UPDATE);
pushMgr.watch(table, new VoidCallback() {
    @Override
    public void success() {
        //订阅成功
    }
    @Override
    public void error(ACException e) {
        //订阅失败，请自行检查参数类型，表名，columns以及监听主键是否与AbleCloud平台新建的数据集监听主键一致等是否有误。
    }
});
</code></pre>

<h4 id="4_3">4、接收已订阅的实时数据</h4>
<pre><code class="java">pushMgr.onReceive(new PayloadCallback&lt;ACPushReceive&gt;() {
    @Override
    public void success(ACPushReceive pushReceive) {
        //pushReceive.getClassName() 表名
        //pushReceive.getOpType() 接收类型，如ACPushTableOpType.CREATE
        //pushReceive.getPayload() 接收数据ACObject格式
    }

    @Override
    public void error(ACException e) {
        //永远不会执行
    }
});
</code></pre>

<h4 id="5">5、取消订阅</h4>
<p>建议在退出订阅的activity之后调用，避免造成流量浪费。</p>
<pre><code class="java">//实例化ACPushTable对象
ACPushTable table = new ACPushTable();
//设置订阅的表名
table.setClassName(&quot;test_class&quot;);
//设置监听主键
ACObject primaryKey = new ACObject();
primaryKey.put(&quot;deviceId&quot;, &quot;10000&quot;);
table.setPrimaryKey(primaryKey);
pushMgr.unwatch(table, new VoidCallback() {
    @Override
    public void success() {
        //取消订阅成功
    }
    @Override
    public void error(ACException e) {
        //取消订阅失败，请自行检查参数类型，表名以及监听主键是否与AbleCloud平台新建的数据集监听主键一致等是否有误。
    }
});
</code></pre>

<h1 id="_29">局域网通信</h1>
<p>功能说明参见<a href="../../features/functions/#_28">功能说明-局域网通信</a>。</p>
<p>获取设备列表（在网络环境差的情况下如果获取不到设备列表会从本地缓存里取设备列表）。</p>
<pre><code class="java">bindMgr.listDevicesWithStatus(new PayloadCallback&lt;List&lt;ACUserDevice&gt;&gt;() {
    @Override
    public void success(List&lt;ACUserDevice&gt; deviceList) {
        for(ACUserDevice device:deviceList){
            /**
              * 设备在线状态(listDeviceWithStatus时返回，listDevice不返回该值)
              * 0不在线 1云端在线 2局域网在线 3云端和局域网同时在线
              * 若只选择直连的通讯方式，则只有在2和3的状态下才能往设备发送成功
              */
            device.getStatus();
        }
    }

    @Override
    public void error(ACException e) {
        //网络错误且之前从来没有获取过设备列表时返回
    }
});
</code></pre>

<p>因为局域网通讯要求设备与APP处于同一个WiFi下，若网络环境变化，如切换WiFi时，直连的状态会发生改变，所以需要监听网络环境变化。</p>
<pre><code class="java">//监听网络变化
ACNetworkChangeReceiver.addEventHandler(new NetEventHandler() {
    @Override
    public void onNetChange() {
        //当手机网络环境变化时，根据具体需求更新界面上的局域网状态或者不做处理或者重新获取设备列表
        getDeviceList();
    }
});
</code></pre>

<p>此外，由于网络环境较差，使得在获取直连设备时有可能会出现丢包情况，所以若需要准确实时的获取局域网状态，则需要增加手动刷新局域网状态的功能。</p>
<pre><code class="java">//当设备掉线或网络环境不稳定导致获取局域网显示状态不准确时，需要手动刷新设备列表与局域网状态
AC.findLocalDevice(1000, new PayloadCallback&lt;List&lt;ACDeviceFind&gt;&gt;() {
    @Override
    public void success(List&lt;ACDeviceFind&gt; acDeviceFinds) {
        //发现局域网设备，根据ACDeviceFind更新局域网在线状态或者重新获取设备列表
        getDeviceList();
    }

    @Override
    public void error(ACException e) {
        //没有局域网设备，更新局域网在线状态或者重新获取设备列表
        getDeviceList();
    }
});
</code></pre>

<p>最后，至于如何通过直连方式给设备发消息，详情见<a href="#_19">和云端通讯</a>部分。</p>
<h1 id="_30">定时任务</h1>
<p>功能介绍参见 <a href="../../features/functions/#_19">功能说明-功能介绍-定时任务</a></p>
<h2 id="skip"><span class="skip">||SKIP||</span></h2>
<h4 id="_31">获取定时管理器</h4>
<p><strong>使用默认时区</strong></p>
<pre><code class="java">ACTimerMgr timerMgr=AC.timerMgr();
</code></pre>

<p><strong>使用自定义时区</strong></p>
<pre><code class="java">ACTimerMgr timerMgr=AC.timerMgr(timeZone);
</code></pre>

<h4 id="_32">添加定时任务</h4>
<blockquote>
<p><strong><font color="red">注意</font>：</strong></p>
<p><strong>1、若与设备之间的通讯为二进制或json格式，则需要先设置序列化器（与发送到设备相同），若为klv格式则不需要设置，具体参考与云端通讯中的发送到设备。</strong></p>
<p><strong>2、timePoint的格式为<code>"yyyy-MM-dd HH:mm:ss"</code>，否则会失败。</strong></p>
<p><strong>3、timeCycle需要在timePoint时间点的基础上,选择循环方式。</strong></p>
<ul>
<li>
<p><strong>"once":</strong>单次循环</p>
</li>
<li>
<p><strong>"min":</strong>在每分钟的<strong><code>ss</code></strong>时间点循环执行</p>
</li>
<li>
<p><strong>"hour":</strong>在每小时的<strong><code>mm:ss</code></strong>时间点循环执行</p>
</li>
<li>
<p><strong>"day":</strong>在每天的<strong><code>HH:mm:ss</code></strong>时间点循环执行</p>
</li>
<li>
<p><strong>"month":</strong>在每月的<strong><code>dd HH:mm:ss</code></strong>时间点循环执行</p>
</li>
<li>
<p><strong>"year":</strong>在每年的<strong><code>MM-dd HH:mm:ss</code></strong>时间点循环执行</p>
</li>
<li>
<p><strong>"week[0,1,2,3,4,5,6]":</strong>在每星期的<strong><code>HH:mm:ss</code></strong>时间点循环执行(如周一，周五重复，则表示为"week[1,5]")</p>
</li>
</ul>
</blockquote>
<pre><code class="java">//设置序列化器，若有klv格式类型，则无需此步骤
AC.bindMgr().setDeviceMsgMarshaller(new ACDeviceMsgMarshaller() {
    @Override
    public byte[] marshal(ACDeviceMsg msg) throws Exception {
         return (byte[]) msg.getContent();
    }

    @Override
    public ACDeviceMsg unmarshal(int msgCode, byte[] payload) throws Exception {
         //跟定时任务无关
         return null;
    }
});
</code></pre>

<pre><code class="java">//若为二进制或klv格式，则msg需要先经过序列化器进行序列化
timerMgr.addTask(deviceId, name, timePoint, timeCycle, description, msg, new VoidCallback() {
     @Override
     public void success() {
          //成功添加定时任务，创建后默认为开启状态
     }

     @Override
     public void error(ACException e) {
          //网络错误或其他，根据e.getErrorCode()做不同的提示或处理，此处一般为参数类型错误，请仔细阅读注意事项
     }
});
</code></pre>

<h4 id="_33">修改定时任务</h4>
<p>接口为modifyTask，其他参数与定义与创建定时任务相同。</p>
<h4 id="_34">开启定时任务</h4>
<pre><code class="java">timerMgr.openTask(deviceId, taskId, new VoidCallback() {
     @Override
     public void success() {
          //开启定时任务成功
     }

     @Override
     public void error(ACException e) {
          //参数无误下一般为网络错误
     }
});
</code></pre>

<h4 id="_35">关闭定时任务</h4>
<pre><code class="java">timerMgr.closeTask(deviceId, taskId, new VoidCallback() {
     @Override
     public void success() {
          //关闭定时任务
     }

     @Override
     public void error(ACException e) {
          //参数无误下一般为网络错误
     }
});
</code></pre>

<h4 id="_36">删除定时任务</h4>
<pre><code class="java">timerMgr.deleteTask(deviceId, taskId, new VoidCallback() {
     @Override
     public void success() {
          //删除定时任务
     }

     @Override
     public void error(ACException e) {
          //参数无误下一般为网络错误
     }
});
</code></pre>

<h4 id="_37">获取定时任务列表</h4>
<pre><code class="java">timerMgr.listTasks(deviceId, new PayloadCallback&lt;List&lt;ACTimerTask&gt;&gt;(){
     @Override
     public void success(List&lt;ACTimerTask&gt; timerTasks) {
          //通过logcat查看获取到的定时任务列表进行显示或下一步操作
          for (ACTimerTask timerTask : timerTasks){
              LogUtil.i(&quot;TAG&quot;, timerTask.toString());
          }
     }

     @Override
     public void error(ACException e) {
          //参数无误下一般为网络错误
     }
});
</code></pre>

<h1 id="ota">OTA</h1>
<p>功能介绍参见 <a href="../../features/functions/#ota">功能说明-功能介绍-OTA</a></p>
<h2 id="skip_1"><span class="skip">||SKIP||</span></h2>
<p><img alt="OTA" src="../../pic/develop_guide/OTA.png" /></p>
<p>说明参见<a href="../../introduction/#ota">功能说明-OTA</a>。</p>
<p>若使用场景为开启APP之后自动检测升级，建议把检测升级过程放在application里，并维护一个deviceId和ACOTAUpgradeInfo的映射关系，通过static修饰放到内存里，在进入OTA升级页面后可以直接取出来显示。如想实现用户取消升级之后不再提示功能，则可以自己维护一个变量记录。</p>
<h4 id="ota_1">一.获取OTA管理器对象</h4>
<pre><code class="java">ACOTAMgr otaMgr = AC.otaMgr();
</code></pre>

<h4 id="_38">二. 检查升级</h4>
<p>检查设备是否有新的OTA版本，同时获取升级日志。</p>
<pre><code class="java">otaMgr.checkUpdate(subDomain, deviceId, new PayloadCallback&lt;ACOTAUpgradeInfo&gt;() {
    @Override
    public void success(ACOTAUpgradeInfo info) {
        /**
         * 通过判断info.getOldVersion()和info.getNewVersion()是否相等判断是否有新版本更新
         * 
         * info.getOldVersion为老版本，info.getNewVersion为新版本，info.getUpgradeLog为升级日志
         */
    }
    @Override
    public void error(ACException e) {
        //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h4 id="_39">三．确认升级</h4>
<pre><code class="java">otaMgr.confirmUpdate(subDomain,deviceId, newVersion, new VoidCallback() {
    @Override
    public void success() {
         //确认升级     
    }
    @Override
    public void error(ACException e) {
         //网络错误或其他，根据e.getErrorCode()做不同的提示或处理
    }
});
</code></pre>

<h1 id="_40">推送</h1>
<p>功能介绍参见 <a href="../../features/functions/#20">功能说明-功能介绍-和云端通信</a></p>
<p>AbleCloud的推送使用<a href="http://www.umeng.com/">友盟</a>的服务，在开发功能之前，现需要进行一些配置。</p>
<h2 id="_41">推送开发准备</h2>
<p>下面以友盟推送为例，介绍开发推送功能前需要做的准备工作。</p>
<p>首先，需要创建友盟推送账号，并创建应用（安卓和iOS版本需要单独创建），如下图所示。</p>
<p><img alt="push1" src="../../pic/develop_guide/push1.png" /> </p>
<p>记录“应用信息”中的AppKey和App Master Secret，将其填写到test.ablecloud.cn中。AbleCloud和友盟已经达成合作协议，服务器IP地址一项不需要填写。</p>
<p><img alt="push2" src="../../pic/develop_guide/push2.png" /> </p>
<p>友盟平台配置完成后，到AbleCloud的管理后台的推送管理页面填写对应信息即可使用AbleCloud提供的推送服务。</p>
<blockquote>
<p><font color="red">注意</font></p>
<p>1、调试的时候若开发环境配置有变化的话尽量手动卸载APP之后再重新安装。</p>
<p>2、推荐先登录友盟推送的后台进行推送测试，若能收到推送通知即代表流程通过，最后再与UDS服务进行下一步测试。</p>
<p>3、推荐先使用友盟推送后台的设备状态查询（通过接口获取）或者设备别名查询（即登录成功之后的userId）等工具确认是否成功注册推送服务。若注册成功之后仍没有收到通知消息，再检查一下开发环境配置。</p>
</blockquote>
<h2 id="_42">一、推送开发环境配置</h2>
<p>如果想使用推送服务，需要先配置AndroidManifest.xml环境变量。</p>
<h4 id="1manifest">1、在<code>&lt;manifest&gt;</code>标签下添加权限：</h4>
<pre><code class="java">&lt;!-- 必选 --&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;
&lt;!-- 用以设置前台是否显示通知--&gt;
&lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot;/&gt;
&lt;!-- 可选  --&gt;
&lt;uses-permission android:name=&quot;android.permission.BROADCAST_PACKAGE_ADDED&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.BROADCAST_PACKAGE_CHANGED&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.BROADCAST_PACKAGE_INSTALL&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.BROADCAST_PACKAGE_REPLACED&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.RESTART_PACKAGES&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot;/&gt;;
</code></pre>

<h4 id="2application">2、在<code>&lt;application&gt;</code>标签下添加组件：</h4>
<p><font color="red">注意</font>：添加组件时需要将【应用包名】替换为你自己应用的包名。</p>
<pre><code class="java">&lt;!-- 监听通知点击或者忽略处理的广播 --&gt;
&lt;receiver
    android:name=&quot;com.umeng.message.NotificationProxyBroadcastReceiver&quot;
    android:exported=&quot;false&quot; &gt;
&lt;/receiver&gt;

&lt;!-- 监听开机运行、网络连接变化、卸载的广播 --&gt;
&lt;receiver
    android:name=&quot;com.umeng.message.SystemReceiver&quot;
    android:process=&quot;:push&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot; /&gt;
        &lt;data android:scheme=&quot;package&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;

&lt;!-- 监听消息到达的广播 --&gt;
&lt;receiver
    android:name=&quot;com.umeng.message.MessageReceiver&quot;
    android:process=&quot;:push&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;org.agoo.android.intent.action.RECEIVE&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;

&lt;!-- 监听宿主选举的广播 --&gt;
&lt;receiver
    android:name=&quot;com.umeng.message.ElectionReceiver&quot;
    android:process=&quot;:push&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;org.agoo.android.intent.action.ELECTION_RESULT_V4&quot; /&gt;
        &lt;category android:name=&quot;umeng&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;

&lt;!-- 监听注册的广播 --&gt;
&lt;!-- 【应用包名】字符串需要替换成本应用的应用包名 --&gt;
&lt;receiver
    android:name=&quot;com.umeng.message.RegistrationReceiver&quot;
    android:exported=&quot;false&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;【应用包名】.intent.action.COMMAND&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
&lt;receiver android:name=&quot;com.umeng.message.UmengMessageBootReceiver&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>

<p>可以根据需要自行设置 android:label 中的服务名 ：</p>
<pre><code class="java">&lt;!-- Umeng的长连服务，用来建立推送的长连接的 --&gt;
&lt;!-- 【应用包名】字符串需要替换成本应用的应用包名 --&gt;
&lt;service
    android:name=&quot;com.umeng.message.UmengService&quot;
    android:label=&quot;PushService&quot;
    android:exported=&quot;true&quot;
    android:process=&quot;:push&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;【应用包名】.intent.action.START&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;【应用包名】.intent.action.COCKROACH&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;org.agoo.android.intent.action.PING_V4&quot; /&gt;
    &lt;category android:name=&quot;umeng&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;

&lt;!-- Umeng的消息接收服务 --&gt;
&lt;service android:name=&quot;com.umeng.message.UmengIntentService&quot; 
    android:process=&quot;:push&quot; /&gt;

&lt;!-- Umeng的消息路由服务 --&gt;
&lt;service 
    android:name=&quot;com.umeng.message.UmengMessageIntentReceiverService&quot;
    android:process=&quot;:push&quot; 
    android:exported=&quot;true&quot; &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;org.android.agoo.client.MessageReceiverService&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;org.android.agoo.client.ElectionReceiverService&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;

&lt;!-- v2.4.1添加的Service，Umeng的消息接收后的处理服务 --&gt;
&lt;service android:name=&quot;com.umeng.message.UmengMessageCallbackHandlerService&quot; 
    android:exported=&quot;false&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.umeng.messge.registercallback.action&quot; /&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.umeng.message.unregistercallback.action&quot;/&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.umeng.message.message.handler.action&quot;/&gt;
    &lt;/intent-filter&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.umeng.message.autoupdate.handler.action&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>

<h4 id="3-appkey-umeng-message-secret">3、添加 AppKey 和 Umeng Message Secret</h4>
<pre><code class="java">&lt;!-- V1.3.0添加的service，负责下载通知的资源 --&gt;
&lt;service android:name=&quot;com.umeng.message.UmengDownloadResourceService&quot; /&gt;

&lt;!-- 添加 AppKey 和 Umeng Message Secret --&gt;
&lt;meta-data
    android:name=&quot;UMENG_APPKEY&quot;
    android:value=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; &gt;
&lt;/meta-data&gt;
&lt;meta-data
    android:name=&quot;UMENG_MESSAGE_SECRET&quot;
    android:value=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; &gt;
&lt;/meta-data&gt;
&lt;!-- 用Channel ID来标识APP的推广渠道，作为推送消息时给用户分组的一个维度，若不设置，则使用Unknown作为Channel ID --&gt;
&lt;meta-data
    android:name=&quot;UMENG_CHANNEL&quot;
    android:value=&quot;Channel ID&quot; &gt;
&lt;/meta-data&gt;
</code></pre>

<h2 id="_43">二、开启推送服务</h2>
<p>AbleCloud在SDK中提供了与推送服务相关的接口（封装了友盟的部分接口），定义如下：</p>
<h4 id="1_9">1、获取推送管理器</h4>
<pre><code class="java">ACNotificationMgr notificationMgr=AC.notificationMgr();
</code></pre>

<h4 id="2activity-oncreate">2、在应用的主Activity onCreate() 函数中开启推送服务</h4>
<pre><code class="java">notificationMgr.init();
</code></pre>

<h4 id="3_6">3、在登录成功之后添加推送别名</h4>
<pre><code class="java">notificationMgr.addAlias(info.getUserId(), new VoidCallback() {
    @Override
    public void success() {
        //别名添加成功
    }
    @Override
    public void error(ACException e) {
        //别名添加失败，检查前面步骤的配置是否有问题
    }   
});
</code></pre>

<h4 id="4_4">4、设置友盟的消息处理</h4>
<pre><code class="java">notificationMgr.setMessageHandler(new UmengMessageHandler() {
    /**
     * 参考集成文档的1.6.3
     * http://dev.umeng.com/push/android/integration#1_6_3
     */
    @Override
    public void dealWithCustomMessage(final Context context, final UMessage msg) {
         new Handler().post(new Runnable() {
             @Override
             public void run() {
                 // TODO Auto-generated method stub
                 Toast.makeText(context, msg.custom, Toast.LENGTH_LONG).show();
                 // 对自定义消息的处理方式，点击或者忽略
                 boolean isClickOrDismissed = true;
                 if (isClickOrDismissed) {
                     //自定义消息的点击统计
                     UTrack.getInstance(getApplicationContext()).trackMsgClick(msg);
                 } else {
                     //自定义消息的忽略统计
                     UTrack.getInstance(getApplicationContext()).trackMsgDismissed(msg);
                 }
             }
         });
    }
    /**
     * 参考集成文档的1.6.4
     * http://dev.umeng.com/push/android/integration#1_6_4
     */
    @Override
    public Notification getNotification(Context context, UMessage msg) {
        //接收到Notification消息处理
        switch (msg.builder_id) {
            case 1:
                NotificationCompat.Builder builder = new NotificationCompat.Builder(context);
                RemoteViews myNotificationView = new RemoteViews(context.getPackageName(), R.layout.notification_view);
                myNotificationView.setTextViewText(R.id.notification_title, msg.title);
                myNotificationView.setTextViewText(R.id.notification_text, msg.text);
                myNotificationView.setImageViewBitmap(R.id.notification_large_icon, getLargeIcon(context, msg));
                myNotificationView.setImageViewResource(R.id.notification_small_icon, getSmallIconId(context, msg));
                builder.setContent(myNotificationView);
                builder.setAutoCancel(true);
                Notification mNotification = builder.build();
                //由于Android v4包的bug，在2.3及以下系统，Builder创建出来的Notification，并没有设置RemoteView，故需要添加此代码
                mNotification.contentView = myNotificationView;
                return mNotification;
            default:
                //默认为0，若填写的builder_id并不存在，也使用默认。
                return super.getNotification(context, msg);
        }
    }
});
</code></pre>

<h4 id="5_1">5、在退出登录之后移除掉旧的别名</h4>
<pre><code class="java">notificationMgr.removeAlias(userId, new VoidCallback() {
    @Override
    public void success() {
         //别名注销成功
    }
    @Override
    public void error(ACException e) {
         //别名注销失败
    }
});
</code></pre>

<h1 id="_44">文件存储</h1>
<p>功能介绍参见 <a href="../../features/functions/#_21">功能说明-功能介绍-文件存储</a></p>
<blockquote>
<p><font color="red">注意</font>：</p>
<p>1、下载文件到sdcard或者从sdcard上传文件到云端需要在 <strong>application</strong> 标签下增加如下权限</p>
<p><code>&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;</code></p>
<p>2、使用文件存储需导入jar包<code>android-async-http-1.4.8</code>和<code>qiniu-android-sdk-7.0.7</code>到libs目录下</p>
<p>3、上传下载支持断点续传功能</p>
</blockquote>
<h2 id="_45">一、获取文件管理器</h2>
<pre><code class="java">ACFileMgr fileMgr = AC.fileMgr();
</code></pre>

<h2 id="_46">二、下载文件</h2>
<h3 id="1url">1、获取下载url</h3>
<pre><code class="java">ACFileInfo fileInfo = new ACFileInfo(bucket, name);
fileMgr.getDownloadUrl(fileInfo, new PayloadCallback&lt;String&gt;() {
    @Override
    public void success(String url) {
         //成功获取文件url
    }

    @Override
    public void error(ACException e) {
         //没有权限或其他网络错误
    }
});
</code></pre>

<h3 id="2url">2、根据url下载文件</h3>
<h4 id="1sdcard">1)、下载文件到sdcard</h4>
<pre><code class="java">ACUtils.createSDDir(&quot;myDir&quot;);
File file = null;
try {
     file = ACUtils.createSDFile(&quot;myDir/&quot; + name);
} catch (IOException e) {
}
fileMgr.downloadFile(file, url, new ProgressCallback() {
    @Override
    public void progress(double progress) {
         //用于显示进度条，百分比，如99.99；如果没有显示进度条的需求则传null
    }
}, new VoidCallback() {
    @Override
    public void success() {
        //下载成功
    }

    @Override
    public void error(ACException e) {
         //支持断点续传，所以此处无网络错误，在恢复网络连接之后会继续下载
    }
});
</code></pre>

<h4 id="2_9">2)、下载文件到内存，比如头像下载</h4>
<pre><code class="java">fileMgr.downloadFile(url, new ProgressCallback() {
    @Override
    public void progress(double progress) {
         //用于显示进度条，百分比，如99.99；此处一般为小文件下载，所以不需要显示进度条的时候传null
    }
}, new PayloadCallback&lt;byte[]&gt;() {
    @Override
    public void success(byte[] bytes) {
         //下载成功
    }

    @Override
    public void error(ACException e) {
         //支持断点续传，所以此处无网络错误，在恢复网络连接之后会继续下载
    }
});
</code></pre>

<h2 id="_47">三、上传文件</h2>
<h3 id="1_10">1、设置上传文件的权限管理</h3>
<pre><code class="java">//acl为权限管理
ACACL acl = new ACACL();
//设置所有人可读，黑名单除外(或者设置所有人不可读，白名单除外)
acl.setPublicReadAccess(true);
//设置所有人可写，黑名单除外(或者设置所有人不可写，白名单除外)
acl.setPublicWriteAccess(true);
//设置黑名单，userId为1的用户没有读的权限
acl.setUserDeny(ACACL.OpType.READ, 1);
//设置白名单，userId为1的用户有写的权限
acl.setUserAccess(ACACL.OpType.WRITE, 1);
</code></pre>

<p><font color="red"><strong>规则</strong>：</font>优先判断黑名单，黑名单命中后其他设置无效，其次判断白名单，最后判断全局设置属性。</p>
<h3 id="2_10">2、上传文件</h3>
<h4 id="1sdcard_1">1)、上传sdcard文件</h4>
<pre><code class="java">ACFileInfo fileInfo = new ACFileInfo(bucket, name);
//设置acl
fileInfo.setACL(acl);
//设置上传文件的sdcard路径
fileInfo.setFile(new File(Environment.getExternalStorageDirectory() + &quot;/myDir/&quot; + name));
fileMgr.uploadFile(fileInfo, new ProgressCallback() {
    @Override
    public void progress(double progress) {
         //用于显示进度条，百分比，如99.99；如果没有显示进度条的需求则传null
    }
}, new VoidCallback() {
    @Override
    public void success() {
         //上传成功
    }

    @Override
    public void error(ACException e) {
         //支持断点续传，所以此处无网络错误，在恢复网络连接之后会继续上传
    }
});
</code></pre>

<h4 id="2_11">2)、上传小文件，比如头像</h4>
<pre><code class="java">ACFileInfo fileInfo = new ACFileInfo(bucket, name);
//设置acl
fileInfo.setACL(acl);
//比如头像比特流数组
fileInfo.setData(bytes);
fileMgr.uploadFile(fileInfo, new ProgressCallback() {
    @Override
    public void progress(double progress) {
         //用于显示进度条，百分比，如99.99；此处一般为小文件上传，所以不需要显示进度条的时候传null
    }
}, new VoidCallback() {
    @Override
    public void success() {
         //上传成功
    }

    @Override
    public void error(ACException e) {
         //支持断点续传，所以此处无网络错误，在恢复网络连接之后会继续上传
    }
});
</code></pre>

<h1 id="error-code">Error Code</h1>
<p>参考<a href="../../reference/error_code/">reference-Error Code</a></p>
<blockquote>
<ul>
<li><strong>建议在调用AbleCloud云服务接口之前先判断网络处于可访问状态之后再调用相关接口，可以省去对error回调里网络错误的处理。</strong></li>
<li><strong>调试阶段，可通过<code>e.getErrorCode()</code>获取错误码，<code>e.getMessage()</code>获取错误信息。</strong></li>
</ul>
</blockquote></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <div class="clear footer">
                &copy;2015&nbsp;&nbsp;北京智云奇点科技有限公司&nbsp;&nbsp;<a href="http://www.miit.gov.cn/" target="_blank">京ICP备14010946号-1</a>
            </div>
        </footer>

        <script type="text/javascript" src="../../js/jquery-1.10.2.min.js"></script>
        <script type="text/javascript" src="../../js/bootstrap.min.js"></script>
        <script type="text/javascript" src="../../js/highlight.pack.js"></script>
        <script type="text/javascript" src="../../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
